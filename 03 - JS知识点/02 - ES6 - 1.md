## ES6 - 基础扩展部分

[toc]

### let 和 count 命令

------

#### let

**作用**

声明变量，用法和 `var`类似

**特点**

使用 `let` 声明的变量只在 `let` 命令所在的代码块中有效

**适合场景**

- for 循环里面的计数器

  ```js
  // 使用 let 定义计数器
  var a = [];
  for (let i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6](); // 6
  ```

  ```js
  // 使用 var 定义计数器的区别
  var a = [];
  for (var i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6](); // 10
  ```

  ```js
  // 关于 for 循环的特别之处：定义变量的地方是一个单独的父级作用域，在循环体内部是一个单独的子作用域
  for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
  }
  // 输出结果：abc、abc、abc
  ```

**注意事项**

1. `没有变量提升`：使用 `let` 声明的变量不存在变量提升现象，所以不能在声明之前使用变量

   ```js
   // var 的情况：相当于执行
   // var foo; console.log(foo);foo = 2 ;
   console.log(foo); // 输出undefined
   var foo = 2;
   
   // let 的情况:此时变量bar还没有声明，不能够直接使用
   console.log(bar); // 报错ReferenceError
   let bar = 2;
   ```

2. `暂时性死区`：使用 `let` 存在暂时性死区 ， 只要该块级作用域内存在 `let`，那么该块级作用域内变量就不会受外部环境的影响，在声明变量前该区域都称为 暂时性死区

   ```js
   var tmp = 123;
   // 此时，下面的块级作用域被称为暂时性死区，在使用 tmp时，tmp还没有声明，所以报错
   if (true) {
     tmp = 'abc'; // ReferenceError
     let tmp;
   }
   ```

   ```javascript
   // 以下这个例子展示一个暂时性死区的开始到结束
   var tmp = 123;
   if (true) {
     // TDZ开始
     tmp = 'abc'; 		// ReferenceError
     console.log(tmp); // ReferenceError
   
     let tmp; // TDZ结束
     console.log(tmp); // undefined
   
     tmp = 123;
     console.log(tmp); // 123
   }
   ```

   > 因为 暂时性死区的存在，使得 typeof 不再是一个百分百安全的操作，如果在 TDZ中使用`typeof` 会报错 `ReferenceError`，所以在es6中如果说 typeof 是一个绝对安全的操作这句话是错误的。

3.  `不允许重复声明`：在相同的作用域内，不允许重复声明变量，否则就会报错。

   ```js
   // 相当于在同一个块级作用域内声明了两次arg变量
   function func(arg) {
     let arg;
   }
   func() // 在执行时会报错
   
   // 在不同的作用域内声明 arg 函数，不会报错
   function func(arg) {
     {
       let arg;
     }
   }
   func()
   ```



#### const

**作用：**

声明一个只读变量，用法类似于 `var`声明变量

**特性：**

使用 `const` 声明的变量，在声明之后不能再修改

```js
const PI = 3.1415;
PI // 3.1415
// 使用coust
PI = 3;// TypeError: Assignment to constant variable.
```

**注意事项：**

1. `必须初始化：`使用 `const` 声明的变量必须初始化，后期都不得再修改。

   ```js
   // 不支持只声明，不赋值，此时会直接报错
   const foo;
   // SyntaxError: Missing initializer in const declaration
   ```

2. `内存地址的固定性`：使用 `const`声明的变量，并不是声明的值不能修改，而是变量指向的内存地址不能修改。对于简单类型的数据（字符串、数值、布尔型），相当于就是定义了一个常量，但是对于引用类型，只能保证声明时的指针是固定的，至于指针所指向的数据结构及其数据就不能保证不变性了，所以使用 `const` 声明对象时一定要注意。

   ```js
   const foo = {};
   
   // 为 foo 添加一个属性，可以成功
   foo.prop = 123;
   foo.prop // 123
   
   // 将 foo 指向另一个对象，就会报错
   foo = {}; // TypeError: "foo" is read-only
   ```

   ```js
   // 如何完全冻结一个对象
   const foo = Object.freeze({});
   
   // 常规模式时，下面一行不起作用；
   // 严格模式时，该行会报错
   foo.prop = 123;
   ```

3. 同 `let` 没有变量提升

4. 同 `let` 具有暂时性死区

5. 同 `let` 不允许重复声明



#### 声明变量的六种方法

- ES5 - var
- ES5 - Function
- ES6 - let
- ES6 - const
- ES6 - class
- ES6 - import



#### 块级作用域





#### 顶层对象

#### globalThis 对象



#### 







### 字符串的扩展



### 数值的扩展



### 函数的扩展



### 数组的扩展



### 对象的扩展





